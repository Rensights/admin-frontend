name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - develop
  push:
    branches:
      - main
      - develop
  workflow_dispatch: # For manual prod deployment

env:
  REGISTRY: ghcr.io
  DEV_NAMESPACE: dev
  PROD_NAMESPACE: prod

jobs:
  # Step 1: Test
  test:
    name: 1️⃣ Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: src/package-lock.json

      - name: Install dependencies
        working-directory: src
        run: npm ci --prefer-offline --no-audit

      - name: Run linter
        working-directory: src
        run: npm run lint || echo "⚠️  Linter warnings (non-blocking)"

      - name: Type check
        working-directory: src
        run: npx tsc --noEmit || echo "⚠️  Type check warnings (non-blocking)"

  # Step 2: Build Docker Image
  build:
    name: 2️⃣ Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.test.result == 'success'
    timeout-minutes: 20
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ github.run_number }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}
          tags: |
            type=raw,value=${{ github.run_number }}
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: linux/amd64
          cache-from: |
            type=gha
            type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:buildcache
          cache-to: |
            type=gha,mode=max
            type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_ADMIN_API_URL || 'http://dev-admin-api.72.62.40.154.nip.io:31416' }}
            NEXT_PUBLIC_MAIN_BACKEND_URL=${{ secrets.NEXT_PUBLIC_MAIN_BACKEND_URL || 'http://dev-api.72.62.40.154.nip.io:31416' }}

      - name: Output image info
        run: |
          echo "✅ Image pushed:"
          echo "${{ steps.meta.outputs.tags }}" | sed 's/^/   /'

  # Step 3: Deploy to Dev (Automatic)
  deploy-dev:
    name: 3️⃣ Deploy to Dev
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && needs.build.result == 'success'
    timeout-minutes: 15
    environment: dev
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          spawn ssh-add "$env(HOME)/.ssh/id_ed25519"
          expect {
            "Enter passphrase" { send "$env(SSH_PASSPHRASE)\r"; exp_continue }
            "Identity added" { expect eof }
            timeout { exit 1 }
          }
          EXPECT_SCRIPT
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          /tmp/ssh-add.exp
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'" || exit 1

      - name: Configure kubectl via SSH tunnel
        run: |
          echo "${{ secrets.DEV_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          SSH_SERVER_IP="72.62.40.154"
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          REMOTE_K8S="$([ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ] && echo "127.0.0.1:6443" || echo "${K8S_SERVER}:6443")"
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup admin-frontend-config secret for dev
        id: admin-frontend-config
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          ADMIN_BACKEND_URL="http://dev-admin-api.72.62.40.154.nip.io:31416"
          MAIN_BACKEND_URL="http://dev-api.72.62.40.154.nip.io:31416"
          
          if kubectl get ingress admin-backend -n ${DEV_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress admin-backend -n ${DEV_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            [ -n "$BACKEND_HOST" ] && ADMIN_BACKEND_URL="http://${BACKEND_HOST}:31416"
          fi
          
          if kubectl get ingress backend -n ${DEV_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress backend -n ${DEV_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            [ -n "$BACKEND_HOST" ] && MAIN_BACKEND_URL="http://${BACKEND_HOST}:31416"
          fi
          
          echo "admin_api_url=${ADMIN_BACKEND_URL}" >> $GITHUB_OUTPUT
          echo "main_backend_url=${MAIN_BACKEND_URL}" >> $GITHUB_OUTPUT
          kubectl create secret generic admin-frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$ADMIN_BACKEND_URL" \
            --from-literal=NEXT_PUBLIC_MAIN_BACKEND_URL="$MAIN_BACKEND_URL" \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy admin-frontend to dev
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          ADMIN_API_URL="${{ steps.admin-frontend-config.outputs.admin_api_url }}"
          MAIN_BACKEND_URL="${{ steps.admin-frontend-config.outputs.main_backend_url }}"
          
          # Check for stuck Helm releases
          if helm list -n ${DEV_NAMESPACE} -q | grep -q "^admin-frontend$"; then
            STATUS=$(helm status admin-frontend -n ${DEV_NAMESPACE} -o json 2>/dev/null | jq -r '.info.status' 2>/dev/null || echo "unknown")
            if [[ "$STATUS" =~ ^(pending-install|pending-upgrade|pending-rollback|failed)$ ]]; then
              echo "⚠️  Cleaning up stuck release (status: $STATUS)..."
              helm rollback admin-frontend -n ${DEV_NAMESPACE} --force 2>&1 || true
              sleep 3
              helm delete admin-frontend -n ${DEV_NAMESPACE} 2>&1 || true
              sleep 3
            fi
          fi
          
          VALUES_FILES="-f env-values/dev/admin-frontend.yaml"
          [ -f "env-values/dev/global.yaml" ] && VALUES_FILES="-f env-values/dev/global.yaml -f env-values/dev/admin-frontend.yaml"
          
          # Check NetworkPolicy
          NETWORK_POLICY_NAME="admin-frontend-allow-kong"
          DISABLE_NP="false"
          if kubectl get networkpolicy ${NETWORK_POLICY_NAME} -n ${DEV_NAMESPACE} >/dev/null 2>&1; then
            HELM_MANAGED=$(kubectl get networkpolicy ${NETWORK_POLICY_NAME} -n ${DEV_NAMESPACE} -o jsonpath='{.metadata.labels.app\.kubernetes\.io/managed-by}' 2>/dev/null || echo "")
            [ "$HELM_MANAGED" != "Helm" ] && DISABLE_NP="true"
          fi
          
          if [ "$DISABLE_NP" = "true" ]; then
            printf 'extraEnv:\n  NEXT_PUBLIC_API_URL: "%s"\n  NEXT_PUBLIC_MAIN_BACKEND_URL: "%s"\nnetworkPolicy:\n  enabled: false\n' \
              "${ADMIN_API_URL}" "${MAIN_BACKEND_URL}" > /tmp/extra-env-values.yaml
          else
            printf 'extraEnv:\n  NEXT_PUBLIC_API_URL: "%s"\n  NEXT_PUBLIC_MAIN_BACKEND_URL: "%s"\n' \
              "${ADMIN_API_URL}" "${MAIN_BACKEND_URL}" > /tmp/extra-env-values.yaml
          fi
          
          helm upgrade --install admin-frontend ./charts \
            --namespace ${DEV_NAMESPACE} \
            --create-namespace \
            ${VALUES_FILES} \
            -f /tmp/extra-env-values.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --atomic --timeout=8m || {
            
            echo "⚠️  Deployment timed out, checking pod status..."
            kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=admin-frontend -o wide
            POD_PHASE=$(kubectl get pod -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=admin-frontend -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "")
            [ "$POD_PHASE" = "Running" ] && exit 0 || exit 1
          }

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=admin-frontend
          kubectl get svc -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=admin-frontend

  # Step 4: Deploy to Prod (Requires Approval)
  deploy-prod:
    name: 4️⃣ Deploy to Prod (Requires Approval)
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'workflow_dispatch'
    timeout-minutes: 15
    environment: 
      name: production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          spawn ssh-add "$env(HOME)/.ssh/id_ed25519"
          expect {
            "Enter passphrase" { send "$env(SSH_PASSPHRASE)\r"; exp_continue }
            "Identity added" { expect eof }
            timeout { exit 1 }
          }
          EXPECT_SCRIPT
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          /tmp/ssh-add.exp
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'" || exit 1

      - name: Configure kubectl via SSH tunnel
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          SSH_SERVER_IP="72.62.40.154"
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          REMOTE_K8S="$([ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ] && echo "127.0.0.1:6443" || echo "${K8S_SERVER}:6443")"
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup admin-frontend-config secret for prod
        id: admin-frontend-config-prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          ADMIN_BACKEND_URL="https://admin-api.72.62.40.154.nip.io"
          MAIN_BACKEND_URL="https://api.72.62.40.154.nip.io"
          
          if kubectl get ingress admin-backend -n ${PROD_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress admin-backend -n ${PROD_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            [ -n "$BACKEND_HOST" ] && ADMIN_BACKEND_URL="https://${BACKEND_HOST}"
          fi
          
          if kubectl get ingress backend -n ${PROD_NAMESPACE} &>/dev/null; then
            BACKEND_HOST=$(kubectl get ingress backend -n ${PROD_NAMESPACE} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
            [ -n "$BACKEND_HOST" ] && MAIN_BACKEND_URL="https://${BACKEND_HOST}"
          fi
          
          echo "admin_api_url=${ADMIN_BACKEND_URL}" >> $GITHUB_OUTPUT
          echo "main_backend_url=${MAIN_BACKEND_URL}" >> $GITHUB_OUTPUT
          kubectl create secret generic admin-frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$ADMIN_BACKEND_URL" \
            --from-literal=NEXT_PUBLIC_MAIN_BACKEND_URL="$MAIN_BACKEND_URL" \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy admin-frontend to prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          [ -n "${{ github.event.inputs.image_tag }}" ] && IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          ADMIN_API_URL="${{ steps.admin-frontend-config-prod.outputs.admin_api_url }}"
          MAIN_BACKEND_URL="${{ steps.admin-frontend-config-prod.outputs.main_backend_url }}"
          
          printf 'extraEnv:\n  NEXT_PUBLIC_API_URL: "%s"\n  NEXT_PUBLIC_MAIN_BACKEND_URL: "%s"\n' \
            "${ADMIN_API_URL}" "${MAIN_BACKEND_URL}" > /tmp/extra-env-values-prod.yaml
          
          helm upgrade --install admin-frontend ./charts \
            --namespace ${PROD_NAMESPACE} \
            --create-namespace \
            -f env-values/prod/global.yaml \
            -f env-values/prod/admin-frontend.yaml \
            -f /tmp/extra-env-values-prod.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --atomic --timeout=8m

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl get pods -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=admin-frontend
          kubectl get svc -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=admin-frontend
