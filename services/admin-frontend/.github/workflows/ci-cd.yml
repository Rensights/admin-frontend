name: CI/CD Pipeline

on:
  pull_request:
    branches:
      - main
      - develop
  push:
    branches:
      - main
      - develop
  workflow_dispatch: # For manual prod deployment

env:
  REGISTRY: ghcr.io
  DEV_NAMESPACE: dev
  PROD_NAMESPACE: prod

jobs:
  # Step 1: Test
  test:
    name: 1️⃣ Run Tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.1
        with:
          fetch-depth: 0
          submodules: false
          clean: true
      
      - name: Check src directory structure
        run: |
          echo "Checking src directory..."
          if [ -d "src" ]; then
            echo "✅ src directory exists"
            ls -la src/ | head -10
            if [ -f "src/package-lock.json" ]; then
              echo "✅ package-lock.json found in src/"
            else
              echo "⚠️  package-lock.json not found in src/"
            fi
          else
            echo "❌ src directory does not exist"
          fi

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Verify package-lock.json exists
        run: |
          if [ -f "src/package-lock.json" ]; then
            echo "✅ Found src/package-lock.json"
            ls -lh src/package-lock.json
          else
            echo "❌ src/package-lock.json not found!"
            echo "Files in src/:"
            ls -la src/ | head -20
            exit 1
          fi

      - name: Get npm cache directory
        id: npm-cache
        shell: bash
        run: |
          echo "dir=$(npm config get cache)" >> $GITHUB_OUTPUT

      - name: Cache npm dependencies
        uses: actions/cache@v4
        with:
          path: ${{ steps.npm-cache.outputs.dir }}
          key: ${{ runner.os }}-node-${{ hashFiles('src/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install dependencies
        working-directory: src
        run: |
          echo "Current directory: $(pwd)"
          echo "Files in current directory:"
          ls -la | head -20
          echo ""
          echo "Checking for package-lock.json:"
          if [ -f "package-lock.json" ]; then
            echo "✅ package-lock.json found"
            ls -lh package-lock.json
            npm ci
          else
            echo "❌ package-lock.json not found, generating it..."
            npm install
          fi

      - name: Run linter
        working-directory: src
        run: npm run lint || echo "⚠️  Linter warnings (non-blocking)"

      - name: Type check
        working-directory: src
        run: npx tsc --noEmit || echo "⚠️  Type check warnings (non-blocking)"

  # Step 2: Build Docker Image
  build:
    name: 2️⃣ Build Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: (github.event_name == 'push' || github.event_name == 'workflow_dispatch') && needs.test.result == 'success'
    permissions:
      contents: read
      packages: write
    outputs:
      image_tag: ${{ github.run_number }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.1
        with:
          fetch-depth: 0
          submodules: false
          clean: true

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}
            ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest
          platforms: linux/amd64
          cache-from: type=registry,ref=ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest
          cache-to: type=inline
          build-args: |
            NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_ADMIN_API_URL }}
            NEXT_PUBLIC_MAIN_BACKEND_URL=${{ secrets.NEXT_PUBLIC_MAIN_BACKEND_URL }}

      - name: Output image info
        run: |
          echo "✅ Image pushed:"
          echo "   ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:${{ github.run_number }}"
          echo "   ghcr.io/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }}:latest"

  # Step 3: Deploy to Dev (Automatic)
  deploy-dev:
    name: 3️⃣ Deploy to Dev
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && needs.build.result == 'success'
    environment: dev
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.1
        with:
          fetch-depth: 0
          submodules: false
          clean: true

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          mkdir -p "$HOME/.ssh"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          set key_path "$env(HOME)/.ssh/id_ed25519"
          spawn ssh-add "$key_path"
          expect {
            "Enter passphrase" {
              send "$env(SSH_PASSPHRASE)\r"
              exp_continue
            }
            "Identity added" {
              expect eof
            }
            eof {
              puts "Process ended"
            }
          }
          EXPECT_SCRIPT
          
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          export HOME="$HOME"
          /tmp/ssh-add.exp || exit 1
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'"

      - name: Configure kubectl via SSH tunnel
        run: |
          echo "${{ secrets.DEV_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          SSH_SERVER_IP="72.62.40.154"
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          
          if [ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ]; then
            REMOTE_K8S="127.0.0.1:6443"
          else
            REMOTE_K8S="${K8S_SERVER}:6443"
          fi
          
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup admin-frontend-config secret for dev
        id: admin-frontend-config
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          ADMIN_API_URL="http://dev-admin-api.72.62.40.154.nip.io:31416"
          MAIN_BACKEND_URL="http://dev-api.72.62.40.154.nip.io:31416"
          
          echo "api_url=${ADMIN_API_URL}" >> $GITHUB_OUTPUT
          echo "main_backend_url=${MAIN_BACKEND_URL}" >> $GITHUB_OUTPUT
          
          kubectl create secret generic admin-frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$ADMIN_API_URL" \
            --from-literal=NEXT_PUBLIC_MAIN_BACKEND_URL="$MAIN_BACKEND_URL" \
            --namespace ${DEV_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy admin-frontend to dev
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG="${{ github.run_number }}"
          fi
          
          API_URL="${{ steps.admin-frontend-config.outputs.api_url }}"
          MAIN_BACKEND_URL="${{ steps.admin-frontend-config.outputs.main_backend_url }}"
          
          if [ -z "$API_URL" ]; then
            API_URL="http://dev-admin-api.72.62.40.154.nip.io:31416"
          fi
          if [ -z "$MAIN_BACKEND_URL" ]; then
            MAIN_BACKEND_URL="http://dev-api.72.62.40.154.nip.io:31416"
          fi
          
          printf 'extraEnv:\n  NEXT_PUBLIC_API_URL: "%s"\n  NEXT_PUBLIC_MAIN_BACKEND_URL: "%s"\n' \
            "${API_URL}" "${MAIN_BACKEND_URL}" > /tmp/extra-env-values.yaml
          
          VALUES_FILES="-f env-values/dev/admin-frontend.yaml"
          if [ -f "env-values/dev/global.yaml" ]; then
            VALUES_FILES="-f env-values/dev/global.yaml -f env-values/dev/admin-frontend.yaml"
          fi
          
          helm upgrade --install admin-frontend ./charts \
            --namespace ${DEV_NAMESPACE} \
            --create-namespace \
            ${VALUES_FILES} \
            -f /tmp/extra-env-values.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --wait --timeout=5m

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl get pods -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=admin-frontend
          kubectl get svc -n ${DEV_NAMESPACE} -l app.kubernetes.io/name=admin-frontend

  # Step 4: Deploy to Prod (Requires Approval)
  deploy-prod:
    name: 4️⃣ Deploy to Prod (Requires Approval)
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'workflow_dispatch'
    environment: 
      name: production
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4.2.1
        with:
          fetch-depth: 0
          submodules: false
          clean: true

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Set image repository (lowercase)
        id: image-repo
        run: |
          REPO_OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO_NAME=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          echo "repo_owner=${REPO_OWNER}" >> $GITHUB_OUTPUT
          echo "repo_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Set up SSH with Passphrase
        run: |
          eval "$(ssh-agent -s)"
          SSH_KEY_PATH="$HOME/.ssh/id_ed25519"
          mkdir -p "$HOME/.ssh"
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > "$SSH_KEY_PATH"
          chmod 600 "$SSH_KEY_PATH"
          
          sudo apt-get update -qq && sudo apt-get install -y -qq expect || true
          
          cat > /tmp/ssh-add.exp << 'EXPECT_SCRIPT'
          #!/usr/bin/expect -f
          set timeout 30
          set key_path "$env(HOME)/.ssh/id_ed25519"
          spawn ssh-add "$key_path"
          expect {
            "Enter passphrase" {
              send "$env(SSH_PASSPHRASE)\r"
              exp_continue
            }
            "Identity added" {
              expect eof
            }
            eof {
              puts "Process ended"
            }
          }
          EXPECT_SCRIPT
          
          chmod +x /tmp/ssh-add.exp
          export SSH_PASSPHRASE="${{ secrets.SSH_PASSPHRASE }}"
          export HOME="$HOME"
          /tmp/ssh-add.exp || exit 1
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null root@72.62.40.154 "echo 'SSH connection successful'"

      - name: Configure kubectl via SSH tunnel
        run: |
          echo "${{ secrets.PROD_KUBECONFIG }}" | base64 -d > /tmp/kubeconfig
          SSH_SERVER_IP="72.62.40.154"
          K8S_SERVER=$(grep -oP 'server:\s*\Khttps://[^:]+' /tmp/kubeconfig | sed 's|https://||' || echo "127.0.0.1")
          
          if [ "${K8S_SERVER}" = "127.0.0.1" ] || [ "${K8S_SERVER}" = "localhost" ]; then
            REMOTE_K8S="127.0.0.1:6443"
          else
            REMOTE_K8S="${K8S_SERVER}:6443"
          fi
          
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -f -N -L 6443:${REMOTE_K8S} root@${SSH_SERVER_IP}
          sleep 2
          sed -i "s|server: https://.*:6443|server: https://127.0.0.1:6443|g" /tmp/kubeconfig
          export KUBECONFIG=/tmp/kubeconfig
          kubectl cluster-info

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.CONTAINER_TOKEN }}

      - name: Configure image pull secrets for GHCR
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl create secret docker-registry ghcr-secret \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.CONTAINER_TOKEN }} \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Setup admin-frontend-config secret for prod
        id: admin-frontend-config-prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          ADMIN_API_URL="https://admin-api.72.62.40.154.nip.io"
          MAIN_BACKEND_URL="https://api.72.62.40.154.nip.io"
          
          echo "api_url=${ADMIN_API_URL}" >> $GITHUB_OUTPUT
          echo "main_backend_url=${MAIN_BACKEND_URL}" >> $GITHUB_OUTPUT
          
          kubectl create secret generic admin-frontend-config \
            --from-literal=NEXT_PUBLIC_API_URL="$ADMIN_API_URL" \
            --from-literal=NEXT_PUBLIC_MAIN_BACKEND_URL="$MAIN_BACKEND_URL" \
            --namespace ${PROD_NAMESPACE} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy admin-frontend to prod
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          IMAGE_TAG="${{ needs.build.outputs.image_tag }}"
          if [ -z "$IMAGE_TAG" ]; then
            IMAGE_TAG="${{ github.run_number }}"
          fi
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          fi
          
          API_URL="${{ steps.admin-frontend-config-prod.outputs.api_url }}"
          MAIN_BACKEND_URL="${{ steps.admin-frontend-config-prod.outputs.main_backend_url }}"
          
          if [ -z "$API_URL" ]; then
            API_URL="https://admin-api.72.62.40.154.nip.io"
          fi
          if [ -z "$MAIN_BACKEND_URL" ]; then
            MAIN_BACKEND_URL="https://api.72.62.40.154.nip.io"
          fi
          
          printf 'extraEnv:\n  NEXT_PUBLIC_API_URL: "%s"\n  NEXT_PUBLIC_MAIN_BACKEND_URL: "%s"\n' \
            "${API_URL}" "${MAIN_BACKEND_URL}" > /tmp/extra-env-values-prod.yaml
          
          helm upgrade --install admin-frontend ./charts \
            --namespace ${PROD_NAMESPACE} \
            --create-namespace \
            -f env-values/prod/global.yaml \
            -f env-values/prod/admin-frontend.yaml \
            -f /tmp/extra-env-values-prod.yaml \
            --set image.tag=${IMAGE_TAG} \
            --set image.repository=${REGISTRY}/${{ steps.image-repo.outputs.repo_owner }}/${{ steps.image-repo.outputs.repo_name }} \
            --set imagePullSecrets[0].name=ghcr-secret \
            --wait --timeout=5m

      - name: Verify deployment
        run: |
          export KUBECONFIG=/tmp/kubeconfig
          kubectl get pods -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=admin-frontend
          kubectl get svc -n ${PROD_NAMESPACE} -l app.kubernetes.io/name=admin-frontend

